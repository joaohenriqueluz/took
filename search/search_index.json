{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Took took is a command-line tool for time tracking and task management, designed to help you efficiently manage and monitor the time spent on various tasks and projects. With took , you can start, pause, and resume tasks, view detailed reports, and manage your time more effectively. It's simple to set up and integrates seamlessly with your workflow. Features Track Time: Start tracking time for specific tasks, allowing you to keep a detailed log of how much time you spend on each task. Pause and Resume: Easily pause and resume tasks, ensuring that your time logs are accurate and reflect actual working hours. Task Creation: Automatically create tasks when starting time tracking for a task that doesn't exist. Task Status: View the status of all tasks, including time spent and the last time they were updated. Task Logs: Log time spent on tasks and store daily logs. Daily Reports: Generate reports to visualize the time spent on tasks over a specified number of days. Persistent Storage: All tasks and time logs are stored in a JSON file within the project directory, ensuring that your data is persistent across sessions and can be committed to the VCS. Contributing We welcome contributions to Took! If you have suggestions, improvements, or bug fixes, please open an issue or submit a pull request on GitHub. License Took is licensed under the MIT License. See LICENSE for more details.","title":"Home"},{"location":"#welcome-to-took","text":"took is a command-line tool for time tracking and task management, designed to help you efficiently manage and monitor the time spent on various tasks and projects. With took , you can start, pause, and resume tasks, view detailed reports, and manage your time more effectively. It's simple to set up and integrates seamlessly with your workflow.","title":"Welcome to Took"},{"location":"#features","text":"Track Time: Start tracking time for specific tasks, allowing you to keep a detailed log of how much time you spend on each task. Pause and Resume: Easily pause and resume tasks, ensuring that your time logs are accurate and reflect actual working hours. Task Creation: Automatically create tasks when starting time tracking for a task that doesn't exist. Task Status: View the status of all tasks, including time spent and the last time they were updated. Task Logs: Log time spent on tasks and store daily logs. Daily Reports: Generate reports to visualize the time spent on tasks over a specified number of days. Persistent Storage: All tasks and time logs are stored in a JSON file within the project directory, ensuring that your data is persistent across sessions and can be committed to the VCS.","title":"Features"},{"location":"#contributing","text":"We welcome contributions to Took! If you have suggestions, improvements, or bug fixes, please open an issue or submit a pull request on GitHub.","title":"Contributing"},{"location":"#license","text":"Took is licensed under the MIT License. See LICENSE for more details.","title":"License"},{"location":"getting-started/","text":"Installation You can install Took using pip: pip install took Usage Initialize a New Project Before using took , initialize it in your project directory: $ took init This command creates a .took directory and initializes the took.json file in the current directory. If no .took directory is found in the current or parent directories, took will fall back to a central directory in your home folder to store tasks. To set up Git hooks for automatic tracking with took : $ took init --git Start Tracking Time To start tracking time for a task: $ took start -t <task_name> If the task doesn't already exist, it will be created automatically. If you don\u2019t specify a task name, took will resume the most recently paused task. Pause Tracking Time To pause the currently active task: $ took pause Even when paused, took can retroactively track time if you forget to resume a task. Mark a Task as Done To mark a task as done: $ took done -t <task_name> This marks the task as done and stops tracking time for it, but its logs will still be available. Remove a Task To permanently remove a task from your tracked list: $ took remove -t <task_name> This deletes the task and its associated time logs. View Task Status To view the current status of all active tasks, including time spent and the last updated time: $ took status This command only shows tasks that are still active (not completed). View All Tracked Tasks To see all tasks being tracked, including both active and completed tasks: $ took show-all --done Use the --done option to include completed tasks. View Task Logs To view the time logged per day for a specific task: $ took log -t <task_name> Generate Daily Reports To generate a report that shows the time spent on each task over the last n days: $ took report -d {n_days} \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 Reports (Last 3 Days) \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f 2024-09-01 Task A: \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 51m-7s Task B: \u2588\u2588\u2588 8m-53s Task C: \u2588\u2588\u2588\u2588 11m-7s 2024-09-02 Task A: \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 11h-57m-47s Task B: \u2588\u2588 1h-47m-12s Task C: \u2588\u2588\u2588\u2588\u2588\u2588 4h-10m-8s 2024-09-03 Task A: \u2588\u2588\u2588\u2588\u2588\u2588 27m-21s Task B: \u2588\u2588\u2588\u2588\u2588 20m-55s Task C: \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 1h-12m-47s This report displays the time spent on each task over the given time period, broken down by day.","title":"Getting started"},{"location":"getting-started/#installation","text":"You can install Took using pip: pip install took","title":"Installation"},{"location":"getting-started/#usage","text":"","title":"Usage"},{"location":"getting-started/#initialize-a-new-project","text":"Before using took , initialize it in your project directory: $ took init This command creates a .took directory and initializes the took.json file in the current directory. If no .took directory is found in the current or parent directories, took will fall back to a central directory in your home folder to store tasks. To set up Git hooks for automatic tracking with took : $ took init --git","title":"Initialize a New Project"},{"location":"getting-started/#start-tracking-time","text":"To start tracking time for a task: $ took start -t <task_name> If the task doesn't already exist, it will be created automatically. If you don\u2019t specify a task name, took will resume the most recently paused task.","title":"Start Tracking Time"},{"location":"getting-started/#pause-tracking-time","text":"To pause the currently active task: $ took pause Even when paused, took can retroactively track time if you forget to resume a task.","title":"Pause Tracking Time"},{"location":"getting-started/#mark-a-task-as-done","text":"To mark a task as done: $ took done -t <task_name> This marks the task as done and stops tracking time for it, but its logs will still be available.","title":"Mark a Task as Done"},{"location":"getting-started/#remove-a-task","text":"To permanently remove a task from your tracked list: $ took remove -t <task_name> This deletes the task and its associated time logs.","title":"Remove a Task"},{"location":"getting-started/#view-task-status","text":"To view the current status of all active tasks, including time spent and the last updated time: $ took status This command only shows tasks that are still active (not completed).","title":"View Task Status"},{"location":"getting-started/#view-all-tracked-tasks","text":"To see all tasks being tracked, including both active and completed tasks: $ took show-all --done Use the --done option to include completed tasks.","title":"View All Tracked Tasks"},{"location":"getting-started/#view-task-logs","text":"To view the time logged per day for a specific task: $ took log -t <task_name>","title":"View Task Logs"},{"location":"getting-started/#generate-daily-reports","text":"To generate a report that shows the time spent on each task over the last n days: $ took report -d {n_days} \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 Reports (Last 3 Days) \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f 2024-09-01 Task A: \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 51m-7s Task B: \u2588\u2588\u2588 8m-53s Task C: \u2588\u2588\u2588\u2588 11m-7s 2024-09-02 Task A: \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 11h-57m-47s Task B: \u2588\u2588 1h-47m-12s Task C: \u2588\u2588\u2588\u2588\u2588\u2588 4h-10m-8s 2024-09-03 Task A: \u2588\u2588\u2588\u2588\u2588\u2588 27m-21s Task B: \u2588\u2588\u2588\u2588\u2588 20m-55s Task C: \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 1h-12m-47s This report displays the time spent on each task over the given time period, broken down by day.","title":"Generate Daily Reports"},{"location":"license/","text":"Took License MIT License Copyright (c) 2024 Jo\u00e3o Henrique Luz Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"Took License"},{"location":"license/#took-license","text":"MIT License Copyright (c) 2024 Jo\u00e3o Henrique Luz Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"Took License"},{"location":"api-reference/git-hooks/","text":"Git Hooks Initializes Git hooks by copying hook scripts into the .git/hooks directory. This function checks if the .git/hooks directory exists in the current working directory. If it does, it copies the predefined Git hook scripts from the package resources to this directory and sets their permissions to make them executable. Hook scripts copied: pre-commit post-commit post-checkout post-merge If the .git directory is not found, a message is printed and no hooks are installed. Raises: FileNotFoundError \u2013 If the hook script resource files cannot be found in the package. Source code in took/git_hooks.py def init_git_hooks(): \"\"\" Initializes Git hooks by copying hook scripts into the .git/hooks directory. This function checks if the .git/hooks directory exists in the current working directory. If it does, it copies the predefined Git hook scripts from the package resources to this directory and sets their permissions to make them executable. Hook scripts copied: - pre-commit - post-commit - post-checkout - post-merge If the .git directory is not found, a message is printed and no hooks are installed. Raises: FileNotFoundError: If the hook script resource files cannot be found in the package. \"\"\" git_dir = os.path.join(os.getcwd(), \".git\", \"hooks\") print(git_dir) if not os.path.exists(git_dir): print(\"No .git directory found. Git hooks will not be installed.\") return hook_files = [\"pre-commit\", \"post-commit\", \"post-checkout\", \"post-merge\"] for hook_name in hook_files: resource_name = f\"resources/hooks/{hook_name}.sh\" resource_path = pkg_resources.resource_filename('took', resource_name) dest_path = os.path.join(git_dir, hook_name) print(dest_path) # Copy the hook script to the .git/hooks directory shutil.copyfile(resource_path, dest_path) # Make the hook script executable os.chmod(dest_path, 0o775) print(\"Git hooks have been initialized.\")","title":"Git Hooks"},{"location":"api-reference/git-hooks/#git-hooks","text":"Initializes Git hooks by copying hook scripts into the .git/hooks directory. This function checks if the .git/hooks directory exists in the current working directory. If it does, it copies the predefined Git hook scripts from the package resources to this directory and sets their permissions to make them executable. Hook scripts copied: pre-commit post-commit post-checkout post-merge If the .git directory is not found, a message is printed and no hooks are installed. Raises: FileNotFoundError \u2013 If the hook script resource files cannot be found in the package. Source code in took/git_hooks.py def init_git_hooks(): \"\"\" Initializes Git hooks by copying hook scripts into the .git/hooks directory. This function checks if the .git/hooks directory exists in the current working directory. If it does, it copies the predefined Git hook scripts from the package resources to this directory and sets their permissions to make them executable. Hook scripts copied: - pre-commit - post-commit - post-checkout - post-merge If the .git directory is not found, a message is printed and no hooks are installed. Raises: FileNotFoundError: If the hook script resource files cannot be found in the package. \"\"\" git_dir = os.path.join(os.getcwd(), \".git\", \"hooks\") print(git_dir) if not os.path.exists(git_dir): print(\"No .git directory found. Git hooks will not be installed.\") return hook_files = [\"pre-commit\", \"post-commit\", \"post-checkout\", \"post-merge\"] for hook_name in hook_files: resource_name = f\"resources/hooks/{hook_name}.sh\" resource_path = pkg_resources.resource_filename('took', resource_name) dest_path = os.path.join(git_dir, hook_name) print(dest_path) # Copy the hook script to the .git/hooks directory shutil.copyfile(resource_path, dest_path) # Make the hook script executable os.chmod(dest_path, 0o775) print(\"Git hooks have been initialized.\")","title":"Git Hooks"},{"location":"api-reference/timetracker/","text":"TimeTracker Class The TimeTracker class is a task management and time-tracking tool that allows users to log, track, and manage time spent on various tasks. It stores task data in a JSON file, maintains logs of time spent, and provides features for starting, pausing, resuming, and completing tasks. Main functionalities: - Task creation, tracking, and removal. - Pausing and resuming tasks, tracking time while active. - Recording time logs per task and generating daily breakdowns. - Loading and saving task data to/from a JSON file. - Command-line interface (CLI) support for controlling task operations. Source code in took/took.py class TimeTracker: \"\"\" The TimeTracker class is a task management and time-tracking tool that allows users to log, track, and manage time spent on various tasks. It stores task data in a JSON file, maintains logs of time spent, and provides features for starting, pausing, resuming, and completing tasks. Main functionalities: - Task creation, tracking, and removal. - Pausing and resuming tasks, tracking time while active. - Recording time logs per task and generating daily breakdowns. - Loading and saving task data to/from a JSON file. - Command-line interface (CLI) support for controlling task operations. \"\"\" def __init__(self): \"\"\" Initializes the TimeTracker object with default values. - Initializes an empty task dictionary. - Sets the current task and root directory to None and pause state to False. \"\"\" self.tasks = {} self.current_task = None self.paused = False self.root = None def init_file(self): \"\"\" Initializes the JSON file for tracking tasks if it doesn't exist. - Creates the directory and file structure for storing the task log. - Initializes the log with default values (empty tasks, no current task, and paused state). \"\"\" if not os.path.exists(TOOK_DIR): os.makedirs(TOOK_DIR) with open(os.path.join(TOOK_DIR, FILE_NAME), 'w', encoding=\"utf-8\") as file: json.dump({ CURRENT: None, TASKS: {}, PAUSED: False }, file, indent=4) print(\"Initialized new empty Took log in the current directory.\") else: print(\"Took log already exists in this directory. No action taken.\") def check_file(self): \"\"\" Checks if the current or any parent directory contains a Took tracker project. - Searches upwards from the current directory. - If no Took directory is found, creates a global Took directory in the user's home directory. Returns: str: The path to the Took directory. \"\"\" current_dir = os.getcwd() while True: if os.path.exists(os.path.join(current_dir, TOOK_DIR)): self.root = os.path.join(current_dir, TOOK_DIR) return self.root parent_dir = os.path.dirname(current_dir) if parent_dir == current_dir: # reached the root without finding .took break current_dir = parent_dir home_dir = os.path.expanduser(\"~\") central_took_dir = os.path.join(home_dir, TOOK_DIR) if not os.path.exists(central_took_dir): os.makedirs(central_took_dir) print(f\"Created a global Took directory at {central_took_dir}\") with open(os.path.join(central_took_dir, FILE_NAME), 'w', encoding=\"utf-8\") as file: json.dump({ CURRENT: None, TASKS: {}, PAUSED: False }, file, indent=4) print(\"Initialized new empty Took log in the current directory.\") self.root = central_took_dir return self.root def load_data(self): \"\"\" Loads task data from the JSON file into the TimeTracker object. - Updates tasks, the current task, and the paused state based on the loaded data. \"\"\" data = { CURRENT: None, TASKS:{} } if (self.root is not None) and os.path.exists(self.root): with open(os.path.join(self.root, FILE_NAME), 'r', encoding=\"utf-8\") as file: data = json.load(file) self.tasks = data[TASKS] self.current_task = data[CURRENT] self.paused = data[PAUSED] def save_data(self): \"\"\" Saves the current state of tasks, the current task, and the paused state to the JSON file. \"\"\" data = { CURRENT: self.current_task, TASKS: self.tasks, PAUSED: self.paused } with open(os.path.join(self.root, FILE_NAME), 'w', encoding=\"utf-8\") as file: json.dump(data, file, indent=4) def create_task(self, task_name): \"\"\" Creates a new task in the tracker. Args: task_name (str): The name of the task to create. \"\"\" self.tasks[task_name] = { TASK_NAME: task_name, LAST_UPDATED: None, TIME_SPENT: 0, LOG: {}, DONE: False } print(f\"Added '{task_name}' to tracked tasks\") def refresh(self): \"\"\" Updates the time spent on the current task by calculating the time elapsed since it was last updated. - If the task is not paused, it updates the daily logs and overall time spent. \"\"\" if self.current_task is None: return current_task = self.tasks[self.current_task] last_updated = datetime.fromisoformat(current_task[LAST_UPDATED]) now = datetime.now() if not self.paused: elapsed_time = now - last_updated seconds_spent = int(elapsed_time.total_seconds()) # Iterate through each day between last_updated and now current_day = last_updated.date() end_day = now.date() while current_day <= end_day: date_str = current_day.isoformat() if current_day == last_updated.date(): # Calculate time from last_updated to end of that day day_end = datetime.combine(current_day, datetime.max.time()) day_end = min(day_end, now) time_for_day = (day_end - last_updated).total_seconds() elif current_day == now.date(): # Calculate time from start of today to now time_for_day = (now - \\ datetime.combine(current_day, datetime.min.time())).total_seconds() else: # Full day (24 hours) time_for_day = 86400 if date_str in current_task[LOG]: current_task[LOG][date_str] += int(time_for_day) else: current_task[LOG][date_str] = int(time_for_day) current_day += timedelta(days=1) current_task[TIME_SPENT] += seconds_spent current_task[LAST_UPDATED] = now.isoformat() def start_task(self, task_name): \"\"\" Starts tracking a new or existing task. - If a task name is provided, it creates the task if it doesn't exist. - If no task is provided, it resumes the current task. Args: task_name (str): The name of the task to start. \"\"\" if task_name is None: self.resume_task() else: self.paused = False if task_name not in self.tasks: self.create_task(task_name) now = datetime.now().isoformat() self.tasks[task_name][LAST_UPDATED] = now self.current_task = task_name print(f\"Started tracking task: '{task_name}' at {now}\") def pause_task(self): \"\"\" Pauses the currently active task. - Prints a message if no task is running. \"\"\" if self.current_task is None: print(\"No task is currently running. No action taken.\") return self.paused = True print(f\"Paused the current task '{self.current_task}'.\") def resume_task(self): \"\"\" Resumes a paused task. - If the current task is not paused or no task is paused, prints a warning message. \"\"\" if self.current_task is None: print(\"No paused task to resume.\") return if not self.paused: print(f\"Current task {self.current_task} is not paused. No action taken.\") return self.paused = False self.refresh() print(f\"Resuming task '{self.current_task}'.\") def remove_task(self, task_name): \"\"\" Removes a task from the tracker. - If the removed task is the current task, stops tracking it. Args: task_name (str): The name of the task to remove. \"\"\" if task_name in self.tasks: del self.tasks[task_name] print(f\"Task '{task_name}' removed from tracked tasks.\") if self.current_task == task_name: self.current_task = None self.paused = True print(\"No task is currently running.\") else: print(f\"Task '{task_name}' not found.\") def done_task(self, task_name): \"\"\" Marks a task as done. - Updates the task's status and stops tracking it if it's the current task. Args: task_name (str): The name of the task to mark as done. \"\"\" if task_name in self.tasks: self.refresh() self.tasks[task_name][DONE] = True print(f\"Task '{task_name}' marked as done.\") if self.current_task == task_name: self.current_task = None self.paused = True print(\"No task is currently running.\") else: print(f\"Task '{task_name}' not found.\") def format_time_spent(self, total_seconds): \"\"\" Formats the total time spent on a task into a human-readable string. Args: total_seconds (int): Total number of seconds to format. Returns: str: A formatted string showing the time spent in years, months, days, hours, minutes, and seconds. \"\"\" seconds_in_year = 60 * 60 * 24 * 365 seconds_in_month = 60 * 60 * 24 * 30 seconds_in_day = 60 * 60 * 24 seconds_in_hour = 60 * 60 seconds_in_minute = 60 years, remainder = divmod(total_seconds, seconds_in_year) months, remainder = divmod(remainder, seconds_in_month) days, remainder = divmod(remainder, seconds_in_day) hours, remainder = divmod(remainder, seconds_in_hour) minutes, seconds = divmod(remainder, seconds_in_minute) parts = [] if years > 0: parts.append(f\"{years}Y-\") if months > 0: parts.append(f\"{months}M-\") if days > 0: parts.append(f\"{days}D-\") if hours > 0: parts.append(f\"{hours}h-\") if minutes > 0: parts.append(f\"{minutes}m-\") if seconds > 0: parts.append(f\"{seconds}s\") return ''.join(parts) if parts else \"0s\" def show_status(self): \"\"\" Displays the current status of all active tasks, including the time spent on each task. - If no tasks are logged, prints a message. \"\"\" self.refresh() if len(self.tasks) == 0: print(\"No tasks logged.\") return for entry in self.tasks.values(): if not entry[DONE]: formatted_time_spent = self.format_time_spent(entry[TIME_SPENT]) print(f\"\\n|Task: {entry[TASK_NAME]}\\ \\n|-Last Updated: {entry[LAST_UPDATED]}\\ \\n|-Time Spent: {formatted_time_spent}\\n\") __init__() Initializes the TimeTracker object with default values. - Initializes an empty task dictionary. - Sets the current task and root directory to None and pause state to False. Source code in took/took.py def __init__(self): \"\"\" Initializes the TimeTracker object with default values. - Initializes an empty task dictionary. - Sets the current task and root directory to None and pause state to False. \"\"\" self.tasks = {} self.current_task = None self.paused = False self.root = None check_file() Checks if the current or any parent directory contains a Took tracker project. Searches upwards from the current directory. If no Took directory is found, creates a global Took directory in the user's home directory. Returns: str \u2013 The path to the Took directory. Source code in took/took.py def check_file(self): \"\"\" Checks if the current or any parent directory contains a Took tracker project. - Searches upwards from the current directory. - If no Took directory is found, creates a global Took directory in the user's home directory. Returns: str: The path to the Took directory. \"\"\" current_dir = os.getcwd() while True: if os.path.exists(os.path.join(current_dir, TOOK_DIR)): self.root = os.path.join(current_dir, TOOK_DIR) return self.root parent_dir = os.path.dirname(current_dir) if parent_dir == current_dir: # reached the root without finding .took break current_dir = parent_dir home_dir = os.path.expanduser(\"~\") central_took_dir = os.path.join(home_dir, TOOK_DIR) if not os.path.exists(central_took_dir): os.makedirs(central_took_dir) print(f\"Created a global Took directory at {central_took_dir}\") with open(os.path.join(central_took_dir, FILE_NAME), 'w', encoding=\"utf-8\") as file: json.dump({ CURRENT: None, TASKS: {}, PAUSED: False }, file, indent=4) print(\"Initialized new empty Took log in the current directory.\") self.root = central_took_dir return self.root create_task(task_name) Creates a new task in the tracker. Parameters: task_name ( str ) \u2013 The name of the task to create. Source code in took/took.py def create_task(self, task_name): \"\"\" Creates a new task in the tracker. Args: task_name (str): The name of the task to create. \"\"\" self.tasks[task_name] = { TASK_NAME: task_name, LAST_UPDATED: None, TIME_SPENT: 0, LOG: {}, DONE: False } print(f\"Added '{task_name}' to tracked tasks\") done_task(task_name) Marks a task as done. Updates the task's status and stops tracking it if it's the current task. Parameters: task_name ( str ) \u2013 The name of the task to mark as done. Source code in took/took.py def done_task(self, task_name): \"\"\" Marks a task as done. - Updates the task's status and stops tracking it if it's the current task. Args: task_name (str): The name of the task to mark as done. \"\"\" if task_name in self.tasks: self.refresh() self.tasks[task_name][DONE] = True print(f\"Task '{task_name}' marked as done.\") if self.current_task == task_name: self.current_task = None self.paused = True print(\"No task is currently running.\") else: print(f\"Task '{task_name}' not found.\") format_time_spent(total_seconds) Formats the total time spent on a task into a human-readable string. Parameters: total_seconds ( int ) \u2013 Total number of seconds to format. Returns: str \u2013 A formatted string showing the time spent in years, months, days, hours, minutes, and seconds. Source code in took/took.py def format_time_spent(self, total_seconds): \"\"\" Formats the total time spent on a task into a human-readable string. Args: total_seconds (int): Total number of seconds to format. Returns: str: A formatted string showing the time spent in years, months, days, hours, minutes, and seconds. \"\"\" seconds_in_year = 60 * 60 * 24 * 365 seconds_in_month = 60 * 60 * 24 * 30 seconds_in_day = 60 * 60 * 24 seconds_in_hour = 60 * 60 seconds_in_minute = 60 years, remainder = divmod(total_seconds, seconds_in_year) months, remainder = divmod(remainder, seconds_in_month) days, remainder = divmod(remainder, seconds_in_day) hours, remainder = divmod(remainder, seconds_in_hour) minutes, seconds = divmod(remainder, seconds_in_minute) parts = [] if years > 0: parts.append(f\"{years}Y-\") if months > 0: parts.append(f\"{months}M-\") if days > 0: parts.append(f\"{days}D-\") if hours > 0: parts.append(f\"{hours}h-\") if minutes > 0: parts.append(f\"{minutes}m-\") if seconds > 0: parts.append(f\"{seconds}s\") return ''.join(parts) if parts else \"0s\" init_file() Initializes the JSON file for tracking tasks if it doesn't exist. - Creates the directory and file structure for storing the task log. - Initializes the log with default values (empty tasks, no current task, and paused state). Source code in took/took.py def init_file(self): \"\"\" Initializes the JSON file for tracking tasks if it doesn't exist. - Creates the directory and file structure for storing the task log. - Initializes the log with default values (empty tasks, no current task, and paused state). \"\"\" if not os.path.exists(TOOK_DIR): os.makedirs(TOOK_DIR) with open(os.path.join(TOOK_DIR, FILE_NAME), 'w', encoding=\"utf-8\") as file: json.dump({ CURRENT: None, TASKS: {}, PAUSED: False }, file, indent=4) print(\"Initialized new empty Took log in the current directory.\") else: print(\"Took log already exists in this directory. No action taken.\") load_data() Loads task data from the JSON file into the TimeTracker object. Updates tasks, the current task, and the paused state based on the loaded data. Source code in took/took.py def load_data(self): \"\"\" Loads task data from the JSON file into the TimeTracker object. - Updates tasks, the current task, and the paused state based on the loaded data. \"\"\" data = { CURRENT: None, TASKS:{} } if (self.root is not None) and os.path.exists(self.root): with open(os.path.join(self.root, FILE_NAME), 'r', encoding=\"utf-8\") as file: data = json.load(file) self.tasks = data[TASKS] self.current_task = data[CURRENT] self.paused = data[PAUSED] pause_task() Pauses the currently active task. - Prints a message if no task is running. Source code in took/took.py def pause_task(self): \"\"\" Pauses the currently active task. - Prints a message if no task is running. \"\"\" if self.current_task is None: print(\"No task is currently running. No action taken.\") return self.paused = True print(f\"Paused the current task '{self.current_task}'.\") refresh() Updates the time spent on the current task by calculating the time elapsed since it was last updated. - If the task is not paused, it updates the daily logs and overall time spent. Source code in took/took.py def refresh(self): \"\"\" Updates the time spent on the current task by calculating the time elapsed since it was last updated. - If the task is not paused, it updates the daily logs and overall time spent. \"\"\" if self.current_task is None: return current_task = self.tasks[self.current_task] last_updated = datetime.fromisoformat(current_task[LAST_UPDATED]) now = datetime.now() if not self.paused: elapsed_time = now - last_updated seconds_spent = int(elapsed_time.total_seconds()) # Iterate through each day between last_updated and now current_day = last_updated.date() end_day = now.date() while current_day <= end_day: date_str = current_day.isoformat() if current_day == last_updated.date(): # Calculate time from last_updated to end of that day day_end = datetime.combine(current_day, datetime.max.time()) day_end = min(day_end, now) time_for_day = (day_end - last_updated).total_seconds() elif current_day == now.date(): # Calculate time from start of today to now time_for_day = (now - \\ datetime.combine(current_day, datetime.min.time())).total_seconds() else: # Full day (24 hours) time_for_day = 86400 if date_str in current_task[LOG]: current_task[LOG][date_str] += int(time_for_day) else: current_task[LOG][date_str] = int(time_for_day) current_day += timedelta(days=1) current_task[TIME_SPENT] += seconds_spent current_task[LAST_UPDATED] = now.isoformat() remove_task(task_name) Removes a task from the tracker. If the removed task is the current task, stops tracking it. Parameters: task_name ( str ) \u2013 The name of the task to remove. Source code in took/took.py def remove_task(self, task_name): \"\"\" Removes a task from the tracker. - If the removed task is the current task, stops tracking it. Args: task_name (str): The name of the task to remove. \"\"\" if task_name in self.tasks: del self.tasks[task_name] print(f\"Task '{task_name}' removed from tracked tasks.\") if self.current_task == task_name: self.current_task = None self.paused = True print(\"No task is currently running.\") else: print(f\"Task '{task_name}' not found.\") resume_task() Resumes a paused task. If the current task is not paused or no task is paused, prints a warning message. Source code in took/took.py def resume_task(self): \"\"\" Resumes a paused task. - If the current task is not paused or no task is paused, prints a warning message. \"\"\" if self.current_task is None: print(\"No paused task to resume.\") return if not self.paused: print(f\"Current task {self.current_task} is not paused. No action taken.\") return self.paused = False self.refresh() print(f\"Resuming task '{self.current_task}'.\") save_data() Saves the current state of tasks, the current task, and the paused state to the JSON file. Source code in took/took.py def save_data(self): \"\"\" Saves the current state of tasks, the current task, and the paused state to the JSON file. \"\"\" data = { CURRENT: self.current_task, TASKS: self.tasks, PAUSED: self.paused } with open(os.path.join(self.root, FILE_NAME), 'w', encoding=\"utf-8\") as file: json.dump(data, file, indent=4) show_status() Displays the current status of all active tasks, including the time spent on each task. If no tasks are logged, prints a message. Source code in took/took.py def show_status(self): \"\"\" Displays the current status of all active tasks, including the time spent on each task. - If no tasks are logged, prints a message. \"\"\" self.refresh() if len(self.tasks) == 0: print(\"No tasks logged.\") return for entry in self.tasks.values(): if not entry[DONE]: formatted_time_spent = self.format_time_spent(entry[TIME_SPENT]) print(f\"\\n|Task: {entry[TASK_NAME]}\\ \\n|-Last Updated: {entry[LAST_UPDATED]}\\ \\n|-Time Spent: {formatted_time_spent}\\n\") start_task(task_name) Starts tracking a new or existing task. If a task name is provided, it creates the task if it doesn't exist. If no task is provided, it resumes the current task. Parameters: task_name ( str ) \u2013 The name of the task to start. Source code in took/took.py def start_task(self, task_name): \"\"\" Starts tracking a new or existing task. - If a task name is provided, it creates the task if it doesn't exist. - If no task is provided, it resumes the current task. Args: task_name (str): The name of the task to start. \"\"\" if task_name is None: self.resume_task() else: self.paused = False if task_name not in self.tasks: self.create_task(task_name) now = datetime.now().isoformat() self.tasks[task_name][LAST_UPDATED] = now self.current_task = task_name print(f\"Started tracking task: '{task_name}' at {now}\")","title":"TimeTracker Class"},{"location":"api-reference/timetracker/#timetracker-class","text":"The TimeTracker class is a task management and time-tracking tool that allows users to log, track, and manage time spent on various tasks. It stores task data in a JSON file, maintains logs of time spent, and provides features for starting, pausing, resuming, and completing tasks. Main functionalities: - Task creation, tracking, and removal. - Pausing and resuming tasks, tracking time while active. - Recording time logs per task and generating daily breakdowns. - Loading and saving task data to/from a JSON file. - Command-line interface (CLI) support for controlling task operations. Source code in took/took.py class TimeTracker: \"\"\" The TimeTracker class is a task management and time-tracking tool that allows users to log, track, and manage time spent on various tasks. It stores task data in a JSON file, maintains logs of time spent, and provides features for starting, pausing, resuming, and completing tasks. Main functionalities: - Task creation, tracking, and removal. - Pausing and resuming tasks, tracking time while active. - Recording time logs per task and generating daily breakdowns. - Loading and saving task data to/from a JSON file. - Command-line interface (CLI) support for controlling task operations. \"\"\" def __init__(self): \"\"\" Initializes the TimeTracker object with default values. - Initializes an empty task dictionary. - Sets the current task and root directory to None and pause state to False. \"\"\" self.tasks = {} self.current_task = None self.paused = False self.root = None def init_file(self): \"\"\" Initializes the JSON file for tracking tasks if it doesn't exist. - Creates the directory and file structure for storing the task log. - Initializes the log with default values (empty tasks, no current task, and paused state). \"\"\" if not os.path.exists(TOOK_DIR): os.makedirs(TOOK_DIR) with open(os.path.join(TOOK_DIR, FILE_NAME), 'w', encoding=\"utf-8\") as file: json.dump({ CURRENT: None, TASKS: {}, PAUSED: False }, file, indent=4) print(\"Initialized new empty Took log in the current directory.\") else: print(\"Took log already exists in this directory. No action taken.\") def check_file(self): \"\"\" Checks if the current or any parent directory contains a Took tracker project. - Searches upwards from the current directory. - If no Took directory is found, creates a global Took directory in the user's home directory. Returns: str: The path to the Took directory. \"\"\" current_dir = os.getcwd() while True: if os.path.exists(os.path.join(current_dir, TOOK_DIR)): self.root = os.path.join(current_dir, TOOK_DIR) return self.root parent_dir = os.path.dirname(current_dir) if parent_dir == current_dir: # reached the root without finding .took break current_dir = parent_dir home_dir = os.path.expanduser(\"~\") central_took_dir = os.path.join(home_dir, TOOK_DIR) if not os.path.exists(central_took_dir): os.makedirs(central_took_dir) print(f\"Created a global Took directory at {central_took_dir}\") with open(os.path.join(central_took_dir, FILE_NAME), 'w', encoding=\"utf-8\") as file: json.dump({ CURRENT: None, TASKS: {}, PAUSED: False }, file, indent=4) print(\"Initialized new empty Took log in the current directory.\") self.root = central_took_dir return self.root def load_data(self): \"\"\" Loads task data from the JSON file into the TimeTracker object. - Updates tasks, the current task, and the paused state based on the loaded data. \"\"\" data = { CURRENT: None, TASKS:{} } if (self.root is not None) and os.path.exists(self.root): with open(os.path.join(self.root, FILE_NAME), 'r', encoding=\"utf-8\") as file: data = json.load(file) self.tasks = data[TASKS] self.current_task = data[CURRENT] self.paused = data[PAUSED] def save_data(self): \"\"\" Saves the current state of tasks, the current task, and the paused state to the JSON file. \"\"\" data = { CURRENT: self.current_task, TASKS: self.tasks, PAUSED: self.paused } with open(os.path.join(self.root, FILE_NAME), 'w', encoding=\"utf-8\") as file: json.dump(data, file, indent=4) def create_task(self, task_name): \"\"\" Creates a new task in the tracker. Args: task_name (str): The name of the task to create. \"\"\" self.tasks[task_name] = { TASK_NAME: task_name, LAST_UPDATED: None, TIME_SPENT: 0, LOG: {}, DONE: False } print(f\"Added '{task_name}' to tracked tasks\") def refresh(self): \"\"\" Updates the time spent on the current task by calculating the time elapsed since it was last updated. - If the task is not paused, it updates the daily logs and overall time spent. \"\"\" if self.current_task is None: return current_task = self.tasks[self.current_task] last_updated = datetime.fromisoformat(current_task[LAST_UPDATED]) now = datetime.now() if not self.paused: elapsed_time = now - last_updated seconds_spent = int(elapsed_time.total_seconds()) # Iterate through each day between last_updated and now current_day = last_updated.date() end_day = now.date() while current_day <= end_day: date_str = current_day.isoformat() if current_day == last_updated.date(): # Calculate time from last_updated to end of that day day_end = datetime.combine(current_day, datetime.max.time()) day_end = min(day_end, now) time_for_day = (day_end - last_updated).total_seconds() elif current_day == now.date(): # Calculate time from start of today to now time_for_day = (now - \\ datetime.combine(current_day, datetime.min.time())).total_seconds() else: # Full day (24 hours) time_for_day = 86400 if date_str in current_task[LOG]: current_task[LOG][date_str] += int(time_for_day) else: current_task[LOG][date_str] = int(time_for_day) current_day += timedelta(days=1) current_task[TIME_SPENT] += seconds_spent current_task[LAST_UPDATED] = now.isoformat() def start_task(self, task_name): \"\"\" Starts tracking a new or existing task. - If a task name is provided, it creates the task if it doesn't exist. - If no task is provided, it resumes the current task. Args: task_name (str): The name of the task to start. \"\"\" if task_name is None: self.resume_task() else: self.paused = False if task_name not in self.tasks: self.create_task(task_name) now = datetime.now().isoformat() self.tasks[task_name][LAST_UPDATED] = now self.current_task = task_name print(f\"Started tracking task: '{task_name}' at {now}\") def pause_task(self): \"\"\" Pauses the currently active task. - Prints a message if no task is running. \"\"\" if self.current_task is None: print(\"No task is currently running. No action taken.\") return self.paused = True print(f\"Paused the current task '{self.current_task}'.\") def resume_task(self): \"\"\" Resumes a paused task. - If the current task is not paused or no task is paused, prints a warning message. \"\"\" if self.current_task is None: print(\"No paused task to resume.\") return if not self.paused: print(f\"Current task {self.current_task} is not paused. No action taken.\") return self.paused = False self.refresh() print(f\"Resuming task '{self.current_task}'.\") def remove_task(self, task_name): \"\"\" Removes a task from the tracker. - If the removed task is the current task, stops tracking it. Args: task_name (str): The name of the task to remove. \"\"\" if task_name in self.tasks: del self.tasks[task_name] print(f\"Task '{task_name}' removed from tracked tasks.\") if self.current_task == task_name: self.current_task = None self.paused = True print(\"No task is currently running.\") else: print(f\"Task '{task_name}' not found.\") def done_task(self, task_name): \"\"\" Marks a task as done. - Updates the task's status and stops tracking it if it's the current task. Args: task_name (str): The name of the task to mark as done. \"\"\" if task_name in self.tasks: self.refresh() self.tasks[task_name][DONE] = True print(f\"Task '{task_name}' marked as done.\") if self.current_task == task_name: self.current_task = None self.paused = True print(\"No task is currently running.\") else: print(f\"Task '{task_name}' not found.\") def format_time_spent(self, total_seconds): \"\"\" Formats the total time spent on a task into a human-readable string. Args: total_seconds (int): Total number of seconds to format. Returns: str: A formatted string showing the time spent in years, months, days, hours, minutes, and seconds. \"\"\" seconds_in_year = 60 * 60 * 24 * 365 seconds_in_month = 60 * 60 * 24 * 30 seconds_in_day = 60 * 60 * 24 seconds_in_hour = 60 * 60 seconds_in_minute = 60 years, remainder = divmod(total_seconds, seconds_in_year) months, remainder = divmod(remainder, seconds_in_month) days, remainder = divmod(remainder, seconds_in_day) hours, remainder = divmod(remainder, seconds_in_hour) minutes, seconds = divmod(remainder, seconds_in_minute) parts = [] if years > 0: parts.append(f\"{years}Y-\") if months > 0: parts.append(f\"{months}M-\") if days > 0: parts.append(f\"{days}D-\") if hours > 0: parts.append(f\"{hours}h-\") if minutes > 0: parts.append(f\"{minutes}m-\") if seconds > 0: parts.append(f\"{seconds}s\") return ''.join(parts) if parts else \"0s\" def show_status(self): \"\"\" Displays the current status of all active tasks, including the time spent on each task. - If no tasks are logged, prints a message. \"\"\" self.refresh() if len(self.tasks) == 0: print(\"No tasks logged.\") return for entry in self.tasks.values(): if not entry[DONE]: formatted_time_spent = self.format_time_spent(entry[TIME_SPENT]) print(f\"\\n|Task: {entry[TASK_NAME]}\\ \\n|-Last Updated: {entry[LAST_UPDATED]}\\ \\n|-Time Spent: {formatted_time_spent}\\n\")","title":"TimeTracker Class"},{"location":"api-reference/timetracker/#took.took.TimeTracker.__init__","text":"Initializes the TimeTracker object with default values. - Initializes an empty task dictionary. - Sets the current task and root directory to None and pause state to False. Source code in took/took.py def __init__(self): \"\"\" Initializes the TimeTracker object with default values. - Initializes an empty task dictionary. - Sets the current task and root directory to None and pause state to False. \"\"\" self.tasks = {} self.current_task = None self.paused = False self.root = None","title":"__init__"},{"location":"api-reference/timetracker/#took.took.TimeTracker.check_file","text":"Checks if the current or any parent directory contains a Took tracker project. Searches upwards from the current directory. If no Took directory is found, creates a global Took directory in the user's home directory. Returns: str \u2013 The path to the Took directory. Source code in took/took.py def check_file(self): \"\"\" Checks if the current or any parent directory contains a Took tracker project. - Searches upwards from the current directory. - If no Took directory is found, creates a global Took directory in the user's home directory. Returns: str: The path to the Took directory. \"\"\" current_dir = os.getcwd() while True: if os.path.exists(os.path.join(current_dir, TOOK_DIR)): self.root = os.path.join(current_dir, TOOK_DIR) return self.root parent_dir = os.path.dirname(current_dir) if parent_dir == current_dir: # reached the root without finding .took break current_dir = parent_dir home_dir = os.path.expanduser(\"~\") central_took_dir = os.path.join(home_dir, TOOK_DIR) if not os.path.exists(central_took_dir): os.makedirs(central_took_dir) print(f\"Created a global Took directory at {central_took_dir}\") with open(os.path.join(central_took_dir, FILE_NAME), 'w', encoding=\"utf-8\") as file: json.dump({ CURRENT: None, TASKS: {}, PAUSED: False }, file, indent=4) print(\"Initialized new empty Took log in the current directory.\") self.root = central_took_dir return self.root","title":"check_file"},{"location":"api-reference/timetracker/#took.took.TimeTracker.create_task","text":"Creates a new task in the tracker. Parameters: task_name ( str ) \u2013 The name of the task to create. Source code in took/took.py def create_task(self, task_name): \"\"\" Creates a new task in the tracker. Args: task_name (str): The name of the task to create. \"\"\" self.tasks[task_name] = { TASK_NAME: task_name, LAST_UPDATED: None, TIME_SPENT: 0, LOG: {}, DONE: False } print(f\"Added '{task_name}' to tracked tasks\")","title":"create_task"},{"location":"api-reference/timetracker/#took.took.TimeTracker.done_task","text":"Marks a task as done. Updates the task's status and stops tracking it if it's the current task. Parameters: task_name ( str ) \u2013 The name of the task to mark as done. Source code in took/took.py def done_task(self, task_name): \"\"\" Marks a task as done. - Updates the task's status and stops tracking it if it's the current task. Args: task_name (str): The name of the task to mark as done. \"\"\" if task_name in self.tasks: self.refresh() self.tasks[task_name][DONE] = True print(f\"Task '{task_name}' marked as done.\") if self.current_task == task_name: self.current_task = None self.paused = True print(\"No task is currently running.\") else: print(f\"Task '{task_name}' not found.\")","title":"done_task"},{"location":"api-reference/timetracker/#took.took.TimeTracker.format_time_spent","text":"Formats the total time spent on a task into a human-readable string. Parameters: total_seconds ( int ) \u2013 Total number of seconds to format. Returns: str \u2013 A formatted string showing the time spent in years, months, days, hours, minutes, and seconds. Source code in took/took.py def format_time_spent(self, total_seconds): \"\"\" Formats the total time spent on a task into a human-readable string. Args: total_seconds (int): Total number of seconds to format. Returns: str: A formatted string showing the time spent in years, months, days, hours, minutes, and seconds. \"\"\" seconds_in_year = 60 * 60 * 24 * 365 seconds_in_month = 60 * 60 * 24 * 30 seconds_in_day = 60 * 60 * 24 seconds_in_hour = 60 * 60 seconds_in_minute = 60 years, remainder = divmod(total_seconds, seconds_in_year) months, remainder = divmod(remainder, seconds_in_month) days, remainder = divmod(remainder, seconds_in_day) hours, remainder = divmod(remainder, seconds_in_hour) minutes, seconds = divmod(remainder, seconds_in_minute) parts = [] if years > 0: parts.append(f\"{years}Y-\") if months > 0: parts.append(f\"{months}M-\") if days > 0: parts.append(f\"{days}D-\") if hours > 0: parts.append(f\"{hours}h-\") if minutes > 0: parts.append(f\"{minutes}m-\") if seconds > 0: parts.append(f\"{seconds}s\") return ''.join(parts) if parts else \"0s\"","title":"format_time_spent"},{"location":"api-reference/timetracker/#took.took.TimeTracker.init_file","text":"Initializes the JSON file for tracking tasks if it doesn't exist. - Creates the directory and file structure for storing the task log. - Initializes the log with default values (empty tasks, no current task, and paused state). Source code in took/took.py def init_file(self): \"\"\" Initializes the JSON file for tracking tasks if it doesn't exist. - Creates the directory and file structure for storing the task log. - Initializes the log with default values (empty tasks, no current task, and paused state). \"\"\" if not os.path.exists(TOOK_DIR): os.makedirs(TOOK_DIR) with open(os.path.join(TOOK_DIR, FILE_NAME), 'w', encoding=\"utf-8\") as file: json.dump({ CURRENT: None, TASKS: {}, PAUSED: False }, file, indent=4) print(\"Initialized new empty Took log in the current directory.\") else: print(\"Took log already exists in this directory. No action taken.\")","title":"init_file"},{"location":"api-reference/timetracker/#took.took.TimeTracker.load_data","text":"Loads task data from the JSON file into the TimeTracker object. Updates tasks, the current task, and the paused state based on the loaded data. Source code in took/took.py def load_data(self): \"\"\" Loads task data from the JSON file into the TimeTracker object. - Updates tasks, the current task, and the paused state based on the loaded data. \"\"\" data = { CURRENT: None, TASKS:{} } if (self.root is not None) and os.path.exists(self.root): with open(os.path.join(self.root, FILE_NAME), 'r', encoding=\"utf-8\") as file: data = json.load(file) self.tasks = data[TASKS] self.current_task = data[CURRENT] self.paused = data[PAUSED]","title":"load_data"},{"location":"api-reference/timetracker/#took.took.TimeTracker.pause_task","text":"Pauses the currently active task. - Prints a message if no task is running. Source code in took/took.py def pause_task(self): \"\"\" Pauses the currently active task. - Prints a message if no task is running. \"\"\" if self.current_task is None: print(\"No task is currently running. No action taken.\") return self.paused = True print(f\"Paused the current task '{self.current_task}'.\")","title":"pause_task"},{"location":"api-reference/timetracker/#took.took.TimeTracker.refresh","text":"Updates the time spent on the current task by calculating the time elapsed since it was last updated. - If the task is not paused, it updates the daily logs and overall time spent. Source code in took/took.py def refresh(self): \"\"\" Updates the time spent on the current task by calculating the time elapsed since it was last updated. - If the task is not paused, it updates the daily logs and overall time spent. \"\"\" if self.current_task is None: return current_task = self.tasks[self.current_task] last_updated = datetime.fromisoformat(current_task[LAST_UPDATED]) now = datetime.now() if not self.paused: elapsed_time = now - last_updated seconds_spent = int(elapsed_time.total_seconds()) # Iterate through each day between last_updated and now current_day = last_updated.date() end_day = now.date() while current_day <= end_day: date_str = current_day.isoformat() if current_day == last_updated.date(): # Calculate time from last_updated to end of that day day_end = datetime.combine(current_day, datetime.max.time()) day_end = min(day_end, now) time_for_day = (day_end - last_updated).total_seconds() elif current_day == now.date(): # Calculate time from start of today to now time_for_day = (now - \\ datetime.combine(current_day, datetime.min.time())).total_seconds() else: # Full day (24 hours) time_for_day = 86400 if date_str in current_task[LOG]: current_task[LOG][date_str] += int(time_for_day) else: current_task[LOG][date_str] = int(time_for_day) current_day += timedelta(days=1) current_task[TIME_SPENT] += seconds_spent current_task[LAST_UPDATED] = now.isoformat()","title":"refresh"},{"location":"api-reference/timetracker/#took.took.TimeTracker.remove_task","text":"Removes a task from the tracker. If the removed task is the current task, stops tracking it. Parameters: task_name ( str ) \u2013 The name of the task to remove. Source code in took/took.py def remove_task(self, task_name): \"\"\" Removes a task from the tracker. - If the removed task is the current task, stops tracking it. Args: task_name (str): The name of the task to remove. \"\"\" if task_name in self.tasks: del self.tasks[task_name] print(f\"Task '{task_name}' removed from tracked tasks.\") if self.current_task == task_name: self.current_task = None self.paused = True print(\"No task is currently running.\") else: print(f\"Task '{task_name}' not found.\")","title":"remove_task"},{"location":"api-reference/timetracker/#took.took.TimeTracker.resume_task","text":"Resumes a paused task. If the current task is not paused or no task is paused, prints a warning message. Source code in took/took.py def resume_task(self): \"\"\" Resumes a paused task. - If the current task is not paused or no task is paused, prints a warning message. \"\"\" if self.current_task is None: print(\"No paused task to resume.\") return if not self.paused: print(f\"Current task {self.current_task} is not paused. No action taken.\") return self.paused = False self.refresh() print(f\"Resuming task '{self.current_task}'.\")","title":"resume_task"},{"location":"api-reference/timetracker/#took.took.TimeTracker.save_data","text":"Saves the current state of tasks, the current task, and the paused state to the JSON file. Source code in took/took.py def save_data(self): \"\"\" Saves the current state of tasks, the current task, and the paused state to the JSON file. \"\"\" data = { CURRENT: self.current_task, TASKS: self.tasks, PAUSED: self.paused } with open(os.path.join(self.root, FILE_NAME), 'w', encoding=\"utf-8\") as file: json.dump(data, file, indent=4)","title":"save_data"},{"location":"api-reference/timetracker/#took.took.TimeTracker.show_status","text":"Displays the current status of all active tasks, including the time spent on each task. If no tasks are logged, prints a message. Source code in took/took.py def show_status(self): \"\"\" Displays the current status of all active tasks, including the time spent on each task. - If no tasks are logged, prints a message. \"\"\" self.refresh() if len(self.tasks) == 0: print(\"No tasks logged.\") return for entry in self.tasks.values(): if not entry[DONE]: formatted_time_spent = self.format_time_spent(entry[TIME_SPENT]) print(f\"\\n|Task: {entry[TASK_NAME]}\\ \\n|-Last Updated: {entry[LAST_UPDATED]}\\ \\n|-Time Spent: {formatted_time_spent}\\n\")","title":"show_status"},{"location":"api-reference/timetracker/#took.took.TimeTracker.start_task","text":"Starts tracking a new or existing task. If a task name is provided, it creates the task if it doesn't exist. If no task is provided, it resumes the current task. Parameters: task_name ( str ) \u2013 The name of the task to start. Source code in took/took.py def start_task(self, task_name): \"\"\" Starts tracking a new or existing task. - If a task name is provided, it creates the task if it doesn't exist. - If no task is provided, it resumes the current task. Args: task_name (str): The name of the task to start. \"\"\" if task_name is None: self.resume_task() else: self.paused = False if task_name not in self.tasks: self.create_task(task_name) now = datetime.now().isoformat() self.tasks[task_name][LAST_UPDATED] = now self.current_task = task_name print(f\"Started tracking task: '{task_name}' at {now}\")","title":"start_task"},{"location":"api-reference/ui/","text":"UI Renderer This module displays task tracking data with enhanced terminal output using the Rich library. It provides functions to show task status, logs, and reports based on time-tracked data from a TimeTracker instance. aggregate_time_per_day(tasks, dates) Aggregates the time spent on all tasks per day. Parameters: tasks ( dict ) \u2013 A dictionary of all tasks with their logs. dates ( list ) \u2013 A list of dates for which to aggregate the time. Returns: dict \u2013 A dictionary with dates as keys and the time spent per task for each day. Source code in took/ui.py def aggregate_time_per_day(tasks, dates): \"\"\" Aggregates the time spent on all tasks per day. Args: tasks (dict): A dictionary of all tasks with their logs. dates (list): A list of dates for which to aggregate the time. Returns: dict: A dictionary with dates as keys and the time spent per task for each day. \"\"\" daily_totals = {date: {} for date in dates} for task_name, task in tasks.items(): for date, seconds in task[\"log\"].items(): if date in daily_totals: if task_name in daily_totals[date]: daily_totals[date][task_name] += seconds else: daily_totals[date][task_name] = seconds return daily_totals get_previous_days(n) Returns a list of the last 'n' days, including today. Parameters: n ( int ) \u2013 The number of days to include. Returns: list \u2013 A list of dates in ISO format, starting from today and going back 'n' days. Source code in took/ui.py def get_previous_days(n): \"\"\" Returns a list of the last 'n' days, including today. Args: n (int): The number of days to include. Returns: list: A list of dates in ISO format, starting from today and going back 'n' days. \"\"\" today = datetime.now().date() return [(today - timedelta(days=i)).isoformat() for i in range(n-1, -1, -1)] show_all_tasks(tt, include_done) Displays a table with all tracked tasks. - Shows the task name, time spent, and the last update for each task. - Highlights the current task and can include or exclude completed tasks. Parameters: tt ( TimeTracker ) \u2013 An instance of the TimeTracker class containing task data. include_done ( bool ) \u2013 Whether to include tasks marked as done in the output. Source code in took/ui.py def show_all_tasks(tt, include_done): \"\"\" Displays a table with all tracked tasks. - Shows the task name, time spent, and the last update for each task. - Highlights the current task and can include or exclude completed tasks. Args: tt (TimeTracker): An instance of the TimeTracker class containing task data. include_done (bool): Whether to include tasks marked as done in the output. \"\"\" console = Console() tasks = tt.tasks if not tasks: console.print(\"No tasks logged.\") return table_style = \"dim\" if tt.paused else \"\" table = Table(show_header=True, header_style=\"bold magenta\") table.add_column(\"\", style=table_style, width=1) table.add_column(\"Task Name\", style=table_style, width=20) table.add_column(\"Time Spent (s)\", style=table_style) table.add_column(\"Last Updated\", style=table_style, width=30) for key, task in tt.tasks.items(): _style = \"\" current_indicator = \"\" task_name = task[TASK_NAME] if (tt.current_task is not None) and (key == tt.current_task): _style = \"bold green\" current_indicator = \"*\" if task[DONE]: if include_done: _style = \"dim\" task_name = \"(done) \" + task_name else: continue formatted_time_spent = tt.format_time_spent(task[TIME_SPENT]) table.add_row(current_indicator, task_name, formatted_time_spent, task[LAST_UPDATED], style=_style) if tt.paused: console.print(Panel(\"Took Tasks' Status\", style=\"bold red\", expand=False, subtitle=\"Paused\")) else: console.print(Panel(\"Took Tasks' Status\", style=\"bold blue\", expand=False)) console.print(table) show_status(tt) Displays the status of the current task. - Shows whether the task is paused or in progress. - Displays the time spent and the last update time. Parameters: tt ( TimeTracker ) \u2013 An instance of the TimeTracker class containing task data. Source code in took/ui.py def show_status(tt): \"\"\" Displays the status of the current task. - Shows whether the task is paused or in progress. - Displays the time spent and the last update time. Args: tt (TimeTracker): An instance of the TimeTracker class containing task data. \"\"\" console = Console() current_task = tt.current_task task_info = tt.tasks.get(current_task, {}) if task_info: console.print(f\"Current Task: {current_task}\", style=\"bold green\", end='') if tt.paused: console.print(\" (paused)\", style=\"red\") else: console.print(\" (in progress)\", style=\"orange1\") formatted_time_spent = tt.format_time_spent(task_info[TIME_SPENT]) console.print(f\"Time Spent (s): {formatted_time_spent}\") console.print(f\"Last Updated: {task_info[LAST_UPDATED]}\") else: console.print(f\"No information available for current task ({current_task}).\") show_task_log(tt, task_name) Displays the log of time spent on a specific task, with a breakdown by day. Parameters: tt ( TimeTracker ) \u2013 An instance of the TimeTracker class containing task data. task_name ( str ) \u2013 The name of the task whose log will be displayed. Source code in took/ui.py def show_task_log(tt, task_name): \"\"\" Displays the log of time spent on a specific task, with a breakdown by day. Args: tt (TimeTracker): An instance of the TimeTracker class containing task data. task_name (str): The name of the task whose log will be displayed. \"\"\" console = Console() task = tt.tasks.get(task_name) if not task: console.print(f\"No task found with the name '{task_name}'\", style=\"bold red\") return console.print(Panel(f\"Task Log for: {task_name}\", style=\"bold green\", expand=False)) table = Table(show_header=True, header_style=\"bold magenta\") table.add_column(\"Date\", style=\"dim\", width=20) table.add_column(\"Time Spent\", style=\"dim\") for date, seconds in sorted(task[\"log\"].items()): formatted_time = tt.format_time_spent(seconds) table.add_row(date, formatted_time) console.print(table) show_task_reports(tt, n_days) Displays a report of time spent on tasks over the last 'n_days'. - Shows each day, with a bar graph of the time spent on each task. Parameters: tt ( TimeTracker ) \u2013 An instance of the TimeTracker class containing task data. n_days ( int ) \u2013 The number of days to include in the report. Source code in took/ui.py def show_task_reports(tt, n_days): \"\"\" Displays a report of time spent on tasks over the last 'n_days'. - Shows each day, with a bar graph of the time spent on each task. Args: tt (TimeTracker): An instance of the TimeTracker class containing task data. n_days (int): The number of days to include in the report. \"\"\" if not n_days: n_days = 1 console = Console() console.print(Panel(f\"Reports (Last {n_days} Days)\", style=\"bold blue\", expand=False)) dates = get_previous_days(n_days) daily_totals = aggregate_time_per_day(tt.tasks, dates) max_bar_length = 30 # Adjust the length of the bar graph for date in dates: console.print(f\"[bold yellow]{date}[/bold yellow]\") day_total_seconds = sum(daily_totals[date].values()) for task_name, seconds in daily_totals[date].items(): bar_length = int((seconds / day_total_seconds) * max_bar_length) if day_total_seconds > 0 else 0 bar = Text(\"\u2588\" * bar_length, style=\"green\") formatted_time = tt.format_time_spent(seconds) console.print(f\"{task_name}: {bar} {formatted_time}\") console.print(\"\")","title":"UI Renderer"},{"location":"api-reference/ui/#ui-renderer","text":"This module displays task tracking data with enhanced terminal output using the Rich library. It provides functions to show task status, logs, and reports based on time-tracked data from a TimeTracker instance.","title":"UI Renderer"},{"location":"api-reference/ui/#took.took.ui.aggregate_time_per_day","text":"Aggregates the time spent on all tasks per day. Parameters: tasks ( dict ) \u2013 A dictionary of all tasks with their logs. dates ( list ) \u2013 A list of dates for which to aggregate the time. Returns: dict \u2013 A dictionary with dates as keys and the time spent per task for each day. Source code in took/ui.py def aggregate_time_per_day(tasks, dates): \"\"\" Aggregates the time spent on all tasks per day. Args: tasks (dict): A dictionary of all tasks with their logs. dates (list): A list of dates for which to aggregate the time. Returns: dict: A dictionary with dates as keys and the time spent per task for each day. \"\"\" daily_totals = {date: {} for date in dates} for task_name, task in tasks.items(): for date, seconds in task[\"log\"].items(): if date in daily_totals: if task_name in daily_totals[date]: daily_totals[date][task_name] += seconds else: daily_totals[date][task_name] = seconds return daily_totals","title":"aggregate_time_per_day"},{"location":"api-reference/ui/#took.took.ui.get_previous_days","text":"Returns a list of the last 'n' days, including today. Parameters: n ( int ) \u2013 The number of days to include. Returns: list \u2013 A list of dates in ISO format, starting from today and going back 'n' days. Source code in took/ui.py def get_previous_days(n): \"\"\" Returns a list of the last 'n' days, including today. Args: n (int): The number of days to include. Returns: list: A list of dates in ISO format, starting from today and going back 'n' days. \"\"\" today = datetime.now().date() return [(today - timedelta(days=i)).isoformat() for i in range(n-1, -1, -1)]","title":"get_previous_days"},{"location":"api-reference/ui/#took.took.ui.show_all_tasks","text":"Displays a table with all tracked tasks. - Shows the task name, time spent, and the last update for each task. - Highlights the current task and can include or exclude completed tasks. Parameters: tt ( TimeTracker ) \u2013 An instance of the TimeTracker class containing task data. include_done ( bool ) \u2013 Whether to include tasks marked as done in the output. Source code in took/ui.py def show_all_tasks(tt, include_done): \"\"\" Displays a table with all tracked tasks. - Shows the task name, time spent, and the last update for each task. - Highlights the current task and can include or exclude completed tasks. Args: tt (TimeTracker): An instance of the TimeTracker class containing task data. include_done (bool): Whether to include tasks marked as done in the output. \"\"\" console = Console() tasks = tt.tasks if not tasks: console.print(\"No tasks logged.\") return table_style = \"dim\" if tt.paused else \"\" table = Table(show_header=True, header_style=\"bold magenta\") table.add_column(\"\", style=table_style, width=1) table.add_column(\"Task Name\", style=table_style, width=20) table.add_column(\"Time Spent (s)\", style=table_style) table.add_column(\"Last Updated\", style=table_style, width=30) for key, task in tt.tasks.items(): _style = \"\" current_indicator = \"\" task_name = task[TASK_NAME] if (tt.current_task is not None) and (key == tt.current_task): _style = \"bold green\" current_indicator = \"*\" if task[DONE]: if include_done: _style = \"dim\" task_name = \"(done) \" + task_name else: continue formatted_time_spent = tt.format_time_spent(task[TIME_SPENT]) table.add_row(current_indicator, task_name, formatted_time_spent, task[LAST_UPDATED], style=_style) if tt.paused: console.print(Panel(\"Took Tasks' Status\", style=\"bold red\", expand=False, subtitle=\"Paused\")) else: console.print(Panel(\"Took Tasks' Status\", style=\"bold blue\", expand=False)) console.print(table)","title":"show_all_tasks"},{"location":"api-reference/ui/#took.took.ui.show_status","text":"Displays the status of the current task. - Shows whether the task is paused or in progress. - Displays the time spent and the last update time. Parameters: tt ( TimeTracker ) \u2013 An instance of the TimeTracker class containing task data. Source code in took/ui.py def show_status(tt): \"\"\" Displays the status of the current task. - Shows whether the task is paused or in progress. - Displays the time spent and the last update time. Args: tt (TimeTracker): An instance of the TimeTracker class containing task data. \"\"\" console = Console() current_task = tt.current_task task_info = tt.tasks.get(current_task, {}) if task_info: console.print(f\"Current Task: {current_task}\", style=\"bold green\", end='') if tt.paused: console.print(\" (paused)\", style=\"red\") else: console.print(\" (in progress)\", style=\"orange1\") formatted_time_spent = tt.format_time_spent(task_info[TIME_SPENT]) console.print(f\"Time Spent (s): {formatted_time_spent}\") console.print(f\"Last Updated: {task_info[LAST_UPDATED]}\") else: console.print(f\"No information available for current task ({current_task}).\")","title":"show_status"},{"location":"api-reference/ui/#took.took.ui.show_task_log","text":"Displays the log of time spent on a specific task, with a breakdown by day. Parameters: tt ( TimeTracker ) \u2013 An instance of the TimeTracker class containing task data. task_name ( str ) \u2013 The name of the task whose log will be displayed. Source code in took/ui.py def show_task_log(tt, task_name): \"\"\" Displays the log of time spent on a specific task, with a breakdown by day. Args: tt (TimeTracker): An instance of the TimeTracker class containing task data. task_name (str): The name of the task whose log will be displayed. \"\"\" console = Console() task = tt.tasks.get(task_name) if not task: console.print(f\"No task found with the name '{task_name}'\", style=\"bold red\") return console.print(Panel(f\"Task Log for: {task_name}\", style=\"bold green\", expand=False)) table = Table(show_header=True, header_style=\"bold magenta\") table.add_column(\"Date\", style=\"dim\", width=20) table.add_column(\"Time Spent\", style=\"dim\") for date, seconds in sorted(task[\"log\"].items()): formatted_time = tt.format_time_spent(seconds) table.add_row(date, formatted_time) console.print(table)","title":"show_task_log"},{"location":"api-reference/ui/#took.took.ui.show_task_reports","text":"Displays a report of time spent on tasks over the last 'n_days'. - Shows each day, with a bar graph of the time spent on each task. Parameters: tt ( TimeTracker ) \u2013 An instance of the TimeTracker class containing task data. n_days ( int ) \u2013 The number of days to include in the report. Source code in took/ui.py def show_task_reports(tt, n_days): \"\"\" Displays a report of time spent on tasks over the last 'n_days'. - Shows each day, with a bar graph of the time spent on each task. Args: tt (TimeTracker): An instance of the TimeTracker class containing task data. n_days (int): The number of days to include in the report. \"\"\" if not n_days: n_days = 1 console = Console() console.print(Panel(f\"Reports (Last {n_days} Days)\", style=\"bold blue\", expand=False)) dates = get_previous_days(n_days) daily_totals = aggregate_time_per_day(tt.tasks, dates) max_bar_length = 30 # Adjust the length of the bar graph for date in dates: console.print(f\"[bold yellow]{date}[/bold yellow]\") day_total_seconds = sum(daily_totals[date].values()) for task_name, seconds in daily_totals[date].items(): bar_length = int((seconds / day_total_seconds) * max_bar_length) if day_total_seconds > 0 else 0 bar = Text(\"\u2588\" * bar_length, style=\"green\") formatted_time = tt.format_time_spent(seconds) console.print(f\"{task_name}: {bar} {formatted_time}\") console.print(\"\")","title":"show_task_reports"}]}